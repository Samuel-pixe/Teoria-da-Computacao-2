# -*- coding: utf-8 -*-
"""Teoria-da-Computação.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/github/Samuel-pixe/Teoria-da-Computacao/blob/main/Teoria_da_Computa%C3%A7%C3%A3o.ipynb

#Fundamentos
"""

#Tipagem dinâmica
a = 1
print(type(a))
a = "1"
print(type(a))
a = 1.0
print(type(a))

s = "Engenharia da Computação"

print(s[0])
print(s[0:5])
print(s[10:14])
print(s[:5])

print(s[-3:])
print(s[0:11]*10)
print ('ç' in s)

s = 'Abcde   '

print(ord(s[0]))
print(len(s))
print(len(s.strip()))
print(s.upper())
print(s.lower())

s1 = '1'
s2 = '2'

print(s1+s2)

n = int(s1)+int(s2)
print(n)

print(s1+s2+str(n))

#entrada de dados
num1 = float(input('Informe um valor'))
num2 = float(input('Informe um valor'))
soma = num1+num2

print("Soma= %.2f" %soma)

print("A soma de {} e {} é igual a {}".format(num1,num2,soma))

a = 2
b = 3
c = 1

if a > b:
  if a > c:
    print('a é o maior')
  else:
    print('c é o maior')
else:
  if b > c:
    print('b é o maior')
  else:
    print('c é o maior')

nome = 'João da Silva'
for letra in nome:
  print(letra)

for i in range(5):
  print(i)

for i in range(1,11):
  print(i)

for i in range(1,11,2):
  print(i)

for i in range(10,0,-1):
  print(i)

cont = 0
while True:
  try:
    n = int(input('Entre com número: '))
    cont = cont + 1
  except Exception as erro:
    print('A entrada não é um número.')
    print(erro)
  finally:
    if cont == 3:
      break;

def exibir(ini=0, fim=10, passo=1):
  for i in range(ini,fim,passo):
    print(i)


#exibir()
#exibir(ini=5)
#exibir(ini=5, fim=7)

def soma(*valores):
  s = 0
  for valor in valores:
    s = s + valor
  return s

print(soma(10,20,30,40,25,31,-3,0,66))

"""#Tuplas => ( )"""

v = (10,"20",30.0,40,"50")

print(v[0])

#for i in v:
  #print(i)

print(v[:])
print(v[0:2])
print(v[1:-1])
print(v[3:])
print(v[::-1])

mat = ( (1,2,3), (4,5,6) )
print(mat)
print(mat[0])
print(mat[0][0])

"""#Listas => []"""

lista1 = []
lista1.append(100)
lista1.append(20)
lista1.append(30)
print(lista1)

lista2 = [40,50,60]
print(lista2)

lista3 = []
lista3.extend(lista1)
lista3.extend(lista2)
print(lista3)

print(len(lista3))
lista3.sort()
print(lista3)

lista3.insert(0,10) #insere o valor 10 na posição 0
print(lista3)

del lista3[-1]      #remove o último elemento da lista
print(lista3)

lista3.remove(60)   #remove o elemento com valor=60
print(lista3)

"""Dicionário => {}"""

dict = {}
dict["nome"] = "João da Silva"
dict["idade"] = 22

print(dict)

for chave,valor in dict.items():
  print("Chave= %s" %chave)
  print("Valor= %s\n" %valor)

"""#Grafo Não-Direcionado"""

# NetworkX
# Pacote python para criação, manipulação e estudo de grafos
# https://networkx.org/
import networkx as nx

#Criação de um grafo não-direcionado
G = nx.Graph()

#Adicionar um vértice (nó) ao grafo
G.add_node("A")
G.add_node("B")
G.add_node("C")
G.add_node("D")
#Adicionar vários vértices de uma vez
G.add_nodes_from(["E","F","G","H"])

#Adicionar uma aresta (edge)
G.add_edge("A","B")
G.add_edge("A","C")
G.add_edge("B","C")
G.add_edge("C","D")
#Adicionar várias arestas de uma vez
G.add_edges_from([("A","E"),("E","F"),("F","G"),("E","H"),])

#Visualizar o grafo
nx.draw(G,with_labels=True)

import networkx as nx

G = nx.Graph()

G.add_nodes_from(["W","O","R","L","D"])
G.add_edges_from([("W","O"),("O","R"),("R","L"),("L","D"),])

#Visualizar o grafo
nx.draw(G,with_labels=True)

"""#Grafo Direcionado"""

import networkx as nx

G = nx.DiGraph()

G.add_node("A")
G.add_node("B")
G.add_node("C")
G.add_node("D")
G.add_nodes_from(["E","F","G","H"])

G.add_edge("A","B")
G.add_edge("A","C")
G.add_edge("B","C")
G.add_edge("C","D")
G.add_edges_from([("A","E"),("E","F"),("F","G"),("E","H"),])

nx.draw(G,with_labels=True)